---
title: "cleaner_data_exploration"
format: html
---

```{r}
library(tidyverse)
library(janitor)
library(dplyr)
library(tmap)
library(sf)
library(here)
library(stars)
library(spData)
library(terra)
```

Load dataframes

```{r}
# Dams
current_dams <- read_sf(here::here('data', 'GRanD_Version_1_3')) %>% 
  clean_names()

future_dams <- read_csv(here::here('data', 'FHReD_2015_future_dams', 'FHRed_2015_future_dams_CSV.csv')) %>% 
  clean_names()

# Population
#global_pop_sf <- read_stars(here::here('data', 'global_pop_2020_CN_1km_R2025A_UA_v1.tif')) %>% 
  #clean_names()
#global_pop_rast <- rast(here::here('data', 'global_pop_2020_CN_1km_R2025A_UA_v1.tif')) %>% 
  #clean_names()

# Water Basin
basin_level3 <- read_sf(here::here('data', 'asia_basin_levels', 'hybas_as_lev03_v1c.shp')) %>% 
  clean_names()

# Rivers
asia_rivers <- read_sf(here::here('data', 'asia_HydroRIVERS.gdb', 'HydroRIVERS_v10_as.gdb')) %>% 
  clean_names()

```

Making `future_dams` spatial

```{r}
future_dams <- st_as_sf(future_dams,
         coords = c('lon_cleaned', 'lat_cleaned'), 
         crs = st_crs(current_dams))
```

Nepal Basin

```{r}
# Filter water basin to Nepal Level 
nepal_basin <- basin_level3 %>% 
  filter(hybas_id == 4030025450)

rm(basin_level3) # Remove basin df 
```

Filtering Rivers to order 2 or 3

```{r}
# Filter rivers at different order levels 

#asia_rivers2 <- asia_rivers %>% 
  #filter(ord_clas == 2)

asia_rivers3 <- asia_rivers %>% 
  filter(ord_clas == 3)

#asia_rivers4 <- asia_rivers %>% 
  #filter(ord_clas == 4)

# Look at difference between river order 2 vs 3 
#tm_shape(asia_rivers2) + 
  #tm_lines()

tm_shape(asia_rivers3) + 
  tm_lines()
```

Making geometeries valid
```{r}
current_dams <- st_make_valid(current_dams)
future_dams <- st_make_valid(future_dams)
nepal_basin <- st_make_valid(nepal_basin)
#asia_rivers2 <- st_make_valid(asia_rivers2)
#asia_rivers3 <- st_make_valid(asia_rivers3)
```

Crop dams and rivers to Nepal basin

```{r}
# Crop dams and rivers to Nepal 
nepal_current_dams <- st_intersection(nepal_basin, current_dams)
nepal_future_dams <- st_intersection(nepal_basin, future_dams)

nepal_rivers <- asia_rivers3 %>%
  st_filter(y = nepal_basin, .predicate = st_intersects)

#nepal_rivers3 <- st_intersection(nepal_basin, asia_rivers3)
#nepal_rivers2 <- st_intersection(nepal_basin, asia_rivers2)


rm(list = c('asia_rivers', 'asia_rivers2', 'asia_rivers3', 'current_dams', 'future_dams'))
```

Bounding box around 1 river with a couple of dams on it

```{r}
# Creating bounding box of 1 river
box_poly <- st_as_sfc(
  st_bbox(c(xmin = 83.56, xmax = 83.6987, ymin = 28.328360, ymax = 28.704314), 
          crs = st_crs(nepal_basin)))

# Check CRS 
st_crs(nepal_basin) == st_crs(box_poly)
```

Map!

```{r}

#tmap_mode("view")
#tmap_mode("plot")


tm_shape(nepal_basin) + 
  tm_polygons(fill_alpha = 0.4, lwd = 2.5) + 
  tm_basemap('Esri.WorldTopoMap') + 
  tm_shape(nepal_current_dams) + 
  tm_dots(fill = "red") + 
  tm_shape(nepal_future_dams) + 
  tm_dots(fill = "blue") + 
  tm_shape(nepal_rivers) + 
  tm_lines() + 
  tm_add_legend(type = "polygons", 
                labels = c("Current Dams", "Future Dams"), 
                fill = c("red", "blue"), 
                title = "Dam Status") + 
  tm_title(text = "Dams in Nepal") + 
  tm_shape(box_poly) + 
  tm_borders(lwd =2, col = "goldenrod")+ 
  tm_compass() + 
  tm_scalebar() 

```

Crop to bounding box
```{r}
trial_current_dams <- st_intersection(box_poly, nepal_current_dams)
trial_future_dams <- st_intersection(box_poly, nepal_future_dams)

trial_river <- nepal_rivers %>%
  st_filter(y = box_poly, .predicate = st_intersects)

```

```{r}
tm_shape(trial_future_dams) + 
  tm_dots(fill = "blue") + 
  tm_shape(trial_river) +
  tm_lines() +
  tm_basemap('Esri.WorldTopoMap')
```

## Finding the distance between future dams on this river

```{r}
# Check CRS 
st_crs(trial_future_dams) == st_crs(trial_river)
st_crs(trial_future_dams) == st_crs(trial_river_simplified)

st_crs(trial_future_dams) # EPSG,32644]
st_crs(trial_river) # EPSG",4326
st_crs(trial_river_simplified) # EPSG",4326

library(riverconn)
```

```{r}
# Union river: multilinestrings -> 1 linestring 
trial_river <- st_union(trial_river)

# Check if dams point overlap 
trial_future_dams %>% 
  st_equals() # Returns TRUE id 2 geometeries are the same 

```

Form the River system based on the intersection of the dams

-   The dam become verticies (nodes) of the river

-   `lwgeom::st_split` splits an an sf 'MULTILINESTRING' object -\> sf multiple 'LINESTRING' geometeries based on the position of the points that perfectly overlap with the polyline

-   `st_distance` is used from points to line to see if 'perfectly overlap'. If `st_distance` returns 0, the dams are on the river. 

```{r}
# Split polyline
trial_river_simplified <- lwgeom::st_split(trial_river, trial_future_dams) %>% # Splits 
  st_collection_extract(., "LINESTRING") %>% 
  data.frame(id = 1:length(.), geometry = .) %>% 
  st_as_sf() %>% 
  mutate(length = st_length(.))

# Check with Map 
tm_shape(trial_river_simplified) + 
  tm_lines() + 
  tm_shape(trial_future_dams) + 
  tm_dots() +
  tm_basemap('Esri.WorldTopoMap')

```

Messing with crs and classes 
```{r}
trial_future_dams <- st_transform(trial_future_dams, crs = 'EPSG:32644')
trial_river_simplified <- st_transform(trial_river_simplified, crs = 'EPSG:32644')
trial_river <- st_transform(trial_river, crs = 'EPSG:32644')

trial_future_dams<- st_as_sf(trial_future_dams)
trial_river<- st_as_sf(trial_river)

```


Snapping the dam points to the river line 
```{r}
# Snap 2 different ways 
snapped <- stppSim::snap_points_to_lines(trial_future_dams, trial_river_simplified) # this worked better! 

source(here::here("snap_to_river_func.R"))
snapped2 <- snap_to_river(trial_future_dams, trial_river)

# Looking at the difference snaps 
tm_shape(snapped2)+ 
  tm_dots(fill = "blue", fill_alpha = 0.5) + # Snapped a dot not on the line 
  tm_shape(snapped) + 
  tm_dots(fill = "red", fill_alpha = 0.5) # Snapped only dots on the line 

# retain only dams that were snapped 
dams_snapped <- snapped[st_contains(trial_river_simplified %>% st_sf(), snapped, prepared = FALSE)[[1]],]
st_distance(dams_snapped, trial_river_simplified) %>% sum

```


```{r}
# Find straight Eudliean distance 
st_distance(snapped) # Returns pairwise distance matrix 

# Distance along line 
sf::st_line_locate_point(trial_river[1,], snapped)
```

```{r}

```





Snap the dam points to the river network 
```{r}
library(riverdist)

# Make a "rivernetwork" 
line <- line2network(sf = trial_river_simplified, reproject = 'EPSG:32644') 
topologydots(rivers=line) # Check for connected-ness
plot(x = line)

# Getting vectors of x and y 
coords_matrix <- st_coordinates(trial_future_dams)
coords_df <- as.data.frame(coords_matrix)
coords_df

# convert x-y coords to a river network coord by snapping points to nearest river vertex 
xy_line <- xy2segvert(x = coords_df$X, y = coords_df$Y, rivers = line)
# `snapdist`: Euclidean distance (straight-line distance) between the original XY point and the point on the river network it was snapped to.

hist(xy_line$snapdist, main="snapping distance (m)")




pointshp2segvert(trial_future_dams, rivers = line)

topologydots(rivers=line)

riverdistance(startseg = 1, endseg = 3, startvert = 1, endvert = 3, rivers = line, map=TRUE)
```

```{r}

```

